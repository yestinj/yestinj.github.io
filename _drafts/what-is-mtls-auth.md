---
title: What is MTLS Authentication
date: 2020-08-03T11:26:05.000Z
categories: [Security]
tags: [mtls]
---

Introduction\nThis week I had the opportunity to implement mutual authentication in a project\nthat I'm working on. I've always been interested in authentication and\ncryptography, however I'd never explored this topic in any detail before, let\nalone implemented it myself on both the client side and server side.\n\nMutual authentication, or mTLS, is simply a way for both a client and a server\nto authenticate each other when they open a connection or communicate. The\nserver proves to the client, by means of a certificate, that it is who the\nclient expects, and vice versa. This provides a greater level of security, and\nprotects against most person-in-the-middle (PITM) attacks. For a much better and\nmore detailed explanation see the page on the subject by Cloudflare, Mutual TLS\nauthentication [https://developers.cloudflare.com/access/service-auth/mtls/].\n\nIn the end, it didn't take me that long to get a workable production\nimplementation in place, however a few of the guides I found online seemed to be\nlacking in small ways, and didn't work for my particular environment and use\ncase. Due to this, I thought it would be worth writing this blog post to help\nothers who may be struggling with similar issues to the ones I encountered.\n\nOverview\nI'll begin by discussing the topic of certificate generation. This covers the\ngeneration of a root certificate, a server certificate, and a client\ncertificate. This post only considers the 'self-signed' case, however it would\nbe very similar when using an actual, recgonised, certificate authority.\nFollowing this, I'll discuss web server configuration, specifically using Nginx.\nI'll then discuss client side implementation in Flutter. Next, I'll discuss some\nof the common problems that I came across while implementing mutual\nauthentication, and finally I'll wrap up with a summary. \n\nI lent heavily on the information in the blog posts by Muhammet GÃœMÃœÅž, namely \nmTLS Client Authentication with NGINX\n[https://blog.apigo.com/mtls-client-certification-auth/] and Client Certificate\nAuthentication (mTLS) with Flutter\n[https://blog.apigo.com/client-authorization-with-flutter/], and by Darshit\nPatel, How To Implement Two Way SSL With Nginx\n[https://dev.to/darshitpp/how-to-implement-two-way-ssl-with-nginx-2g39]. They\nformed the basis for this blog post, I just made tweaks and improvements to suit\nmy use case.\n\nCertificate Generation\n1. Generate root private key and certificate\n# Root CA key\nopenssl genrsa -aes256 -out ca.key 2048\n# Generate the certificate without using a CSR\nopenssl req -new -x509 -days 365 -key ca.key -out ca.crt\n\nGenerate private key and root certificate-aes256 :This is the encryption algorithm to use when encrypting your private\n\tkey. You will be required to provide a password. If you leave this parameter\noff, your private key will not be encrypted, this is NOT recommended. For more\ninfo, see this\n[https://stackoverflow.com/questions/20886145/which-encryption-aes-des-should-i-use-for-private-key-for-ssl-certificate] \ndiscussion.\n\n2048 : This is the keysize to use for your private key. This is the minimum size\nyou should use, as 1024 is now considered too weak (reference\n[https://github.com/ssllabs/research/wiki/SSL-and-TLS-Deployment-Best-Practices]\n).\n\n-days 365 : The validity of the new ceritificate, one year is a safe default,\nespecially for self-signed certificates.\n\nAfter running these two commands and entering the required information you will\nhave a self-signed root certificate and its associated private key. Keep these,\nand the private key password safe, as they will be used to sign server and\nclient certificates in the next steps.\n\n2. Generate server private key and certificate\n# Server key and certificate sign request (CSR)\nopenssl genrsa -aes256 -out server.key 2048\nopenssl req -new -key server.key -out server.csr\n# Sign the CSR with the CA certificate and key\nopenssl x509 -req -days 365 -sha256 -in server.csr -CA ca.crt -CAkey ca.key -set_serial 1 -out server.crt\n\nGenerate private key and server certificate-sha256 : This specifies the signature digest algorithm to use for the new\ncertificate. Without this, OpenSSL may default to a weak algorithm, see Common\nProblems for more information.\n\n-CA and -CAkey : These two parameters specify the filename of the root\ncertificate and its corresponding private key, that were generated in step 1.\n\nImportant: When entering the CSR information, make sure you enter a DIFFERENT\nOrganisation than you used in the root certificate, in step 1. For example, you\ncould use <COMPANY NAME> for the root certificate, and \"<COMPANY NAME> - Server\"\nfor the server. If you use the same organisation, verification of the\ncertificate will fail.\n\nYou should now have the private key and a newly generated server certificate.\n\n3. Generate client private key and certificate\n# Client key and CSR\nopenssl genrsa -aes256 -out client.key 2048\nopenssl req -new -key client.key -out client.csr\n# Sign the client CSR with CA certificate and key\nopenssl x509 -req -days 365 -sha256 -in client.csr -CA ca.crt -CAkey ca.key -set_serial 01 -out client.crt\n\nGenerate private key and client certificateImportant: Make sure you use a different Organisation name from your root\ncertificate, as described in step 2.\n\nAt this stage you can verify the client, or server, certificate against the root\ncertificate, by using: \n\nopenssl verify -verbose -CAfile ca.crt client.crt\n\nVerify a certificateThis command will produce a failure if you generated your\nclient certificate with the same Organisation name as your root certificate. \n\nYou should now have a private key and client certificate. \n\nWeb Server (Nginx) Configuration\nNow that you have the required certificates and their private keys, the next\nstep is to setup your webserver in order to utilize and validate them.\n\nIn this case I use Nginx, setup as a reverse proxy. It will forward\nauthenticated incoming requests to a backend service to handle them. It's also\npossible to set this up in different ways depending on your requirements. \n\nBelow is a example of a minimal Nginx configuration file that you can use in\norder to implement mutual authenticattion. You will likely need to incorporate\nthe relevant config options in your existing Nginx file. Make sure you copy \nserver.crt, server.key, and ca.crt,to a location where Nginx can access it, e.g.\nunder /etc/nginx/certs/.\n\nhttp {\n    server {\n        listen 443 ssl;\n        server_name <SERVER_NAME>;\n\n        # See https://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_ssl_server_name\n        proxy_ssl_server_name on;\n\n        # Server SSL certificate and private key\n        ssl_certificate     /etc/nginx/certs/server.crt;\n        ssl_certificate_key /etc/nginx/certs/server.key;\n        # Contains the password to decrypt the key above\n        ssl_password_file /var/lib/nginx/ssl_passwords.txt;\n\n        # The CA cert against which the client will be validated\n        # The Client certificate might be created from a different\n        # CA than the Server one      \n        ssl_client_certificate /etc/nginx/certs/ca.crt;\n\n        # Validate client certificate (or optional_no_ca for no validation)\n        ssl_verify_client on;\n\n        # Number of intermediate certificates to verify.\n        # https://cheapsslsecurity.com/p/what-is-ssl-certificate-chain/\n        ssl_verify_depth 2;\n\n        ssl_protocols TLSv1.2 TLSv1.3;\n        ssl_ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384;\n        ssl_prefer_server_ciphers off;\n\n        location / {\n            proxy_set_header   X-Forwarded-For $remote_addr;\n            proxy_set_header   Host $http_host;\n            \n            # certificate verification information\n            # If client cert is verified, this will be 'SUCCESS'\n            proxy_set_header VERIFIED $ssl_client_verify;\n            # client certificate information (DN)\n            proxy_set_header DN $ssl_client_s_dn;\n            # Replace with the URL of the service\n            proxy_pass         \"http://<BACKEND_API_HOST>:<PORT>\";\n        }\n    }\n}\n\nSample Nginx configurationSome of the options in this config were set using\nguidance from Mozilla\n[https://ssl-config.mozilla.org/#server=nginx&version=1.17.7&config=intermediate&openssl=1.1.1d&hsts=false&ocsp=false&guideline=5.6]\n, you can customise it however you like.\n\nThe most important configuration options for mutual authentication are:\n\n 1. ssl_certificate <LOCATION OF SERVER CERTIFICATE>\n 2. ssl_certificate_key <LOCATION OF SERVER PRIVATE KEY>\n 3. ssl_password_file <LOCATION OF PRIVATE KEY PASSWORD FILE>\n 4. ssl_client_certificate <LOCATION OF CLIENT CERTIFICATE AUTHORITY>\n 5. ssl_verifiy_client on \n 6. proxy_set_header VERIFIED $ssl_client_verify\n 7. proxy_pass <URL_TO_FORWARD_TO>\n\nDecrypting the server's private key\nAs you may have noticed above, we set the ssl_password_file config option to the\npath of a password file. This is necessary because when we created the server\nprivate key, we chose to encrypt it and provide a password. In order for Nginx\nto decrypt the private key, it needs this password.\n\nThere are various ways this can be done, but one of the simplest is to create a\nnew file, e.g. ssl_passwords.txt and place the plaintext password for the server\nprivate key in it. Then copy it somewhere accessible to Nginx, and ensure you\nreflect its path in the config. More information on this subject can be found \nhere [https://www.nginx.com/blog/secure-distribution-ssl-private-keys-nginx/]. \n\nTesting with cURL\nAt this point, you should be able to test your server configuration for Nginx by\nutilising cURL and providing the necessary certificates. This is described in\nmore detail in this article [https://downey.io/notes/dev/curl-using-mutual-tls/]\n.\n\ncurl -v -k --cacert ca.crt \\\n     --key client.key \\\n     --cert client.crt \\\n     https://<SERVER_HOST>:<SERVER_PORT>\n\n\ncURL command for testing mutual authenticationThis command will complete\nsuccessfully if you've set everything up properly. Be sure to setup another\nserver to handle the proxied request, which Nginx will pass to it (proxy_pass).\nIf it does not work, review the above steps, and consult the Nginx debug error\nlog for more detail on what the problem might be.\n\nClient (Flutter) Configuration\nI'll now cover how to implement the client side of mutual authentication in\nDart/Flutter. I used the Dio [https://pub.dev/packages/dio] library as it is an\ninteresting project, and I found the implementation to be the easiest. It is\ndiscussed in more detail here\n[https://medium.com/@ashmikattel/dio-in-flutter-ad6ba26aee36]. The process will\nbe very similar in other languages. The general approach is to include the\nclient certificate and private key in the client project, then read them in\nbefore use (providing the client key password), and finally instantiate a new\nHTTP client, which will be used for authenticated requests to the server.\n\n// First read in the cert and key bytes\nfinal List<int> certificateChainBytes =\n      (await rootBundle.load('lib/assets/certs/client.crt')).buffer.asInt8List();\nfinal List<int> keyBytes =\n      (await rootBundle.load('lib/assets/certs/client.key')).buffer.asInt8List();\n\n// Create Dio and set it up with a new HttpClient\nDio dio = new Dio();\n(_dio.httpClientAdapter as DefaultHttpClientAdapter).onHttpClientCreate =\n      (client) {\n    SecurityContext sc = new SecurityContext(withTrustedRoots: true);\n    sc.useCertificateChainBytes(certificateChainBytes);\n    // Replace CLIENT_KEY_PASS with your client key password\n    sc.usePrivateKeyBytes(keyBytes, password: CLIENT_KEY_PASS);\n    HttpClient httpClient = new HttpClient(context: sc);\n    // Allow self-signed certs, change this to false to disallow this\n    httpClient.badCertificateCallback =\n        (X509Certificate cert, String host, int port) {\n      return true;\n    };\n    return httpClient;\n  };\n}\n\n// Then perform an HTTP request using Dio\n// Anything besides a 200 and 304 will result in a DioError\ntry {\n  Response response = await dio.get(\"<URL TO QUERY>\");\n} on DioError catch (e) {\n  throw e;\n}\n\nCode snippet for client side implementation in FlutterCommon Problems\nHere I'll cover some of the problems that I came across while implementing\nmutual authentication between an Nginx reverse proxy and a Flutter client.\n\n1. Weak Signature Digest Algorithm\nAs mentioned in the Generating Certificates section, if you leave off the \n-sha256 parameter in the openssl x509 command, you could run into trouble. This\nis due to the fact that, by default, openssl will use a signature algorithm that\nthe latest version of Nginx considers weak, resulting in a verification error.\n\nIn my case, Nginx would fail with the following error:\n\n[info] 28#28: *3 client SSL certificate verify error: (68:CA signature digest algorithm too weak) while reading client request headers, client: 172.29.0.1, server: localhost, request: \"GET / HTTP/1.1\", host: \"localhost:443\"\n\nYou don't have to use -sha256 here, des3 is also another acceptably secure\noption.\n\nThis error seems fairly common and is described in more detail here\n[https://callocorg.wordpress.com/2020/07/02/ca-md-too-weak-ca-signature-digest-algorithm-too-weak/]\n.\n\n2. Nginx HTTP Response 495\nThis Nginx HTTP response code means there was an error with the SSL certificate\n[https://dynomapper.com/blog/254-the-6-types-of-http-status-codes-explained].\nThe error returned by Nginx is not very descriptive, even in the error logs.\nThis code will be returned when Nginx fails to verify a client certificate for\nsome reason. \n\nIn this case however, this error could mean that you generated your root and\nclient certificates with the same Organisation, because of this Nginx considers\nit 'self-signed', as usually these two should not be the same.\n\n[info] 21#21: *3 client SSL certificate verify error: (18:self signed certificate) while reading client request headers, client: 172.29.0.1, server: localhost, request: \"GET / HTTP/1.1\", host: \"localhost:443\"\n\nThis error also seems to be fairly common, as can be seen in this discussion\n[https://stackoverflow.com/questions/45628601/client-authentication-using-self-signed-ssl-certificate-for-nginx]\n.\n\nSummary\nIn conclusion, a brief summary of all of the steps that I have discussed here,\nwhich are required in order to implement mutual authentication:\n\n 1. Generate a root certificate and a private key.\n 2. Generate server and client certificates and private keys.\n 3. Configure Nginx to use the root and server certificates, and to verify\n    client certificates in incoming requests.\n 4. Implement reading in and sending the client certificate with HTTPS requests\n    from the client\n\nThanks for reading. Any constructive feedback is most welcome ðŸ˜Š\n\nFuture Work\nThere are various aspects of mutual authentication between a server and a client\nthat I believe can be optimised further than I have done here. I plan to spend\nsome time researching these topics, and perhaps writing corresponding blog\nposts, in the future.\n\n 1. Use of the ECDSA signature algorithm over RSA when generating certificates.\n    Reference: \n    https://blog.cloudflare.com/ecdsa-the-digital-signature-algorithm-of-a-better-internet/\n 2. A more secure storage of the server private key password. For example, this\n    could be fetching the key via a secrets vault distributed via encrypted\n    environmental variables.\n 3. A more secure way of password storage and key and certificate use in the\n    client, for example: fetching the client private key password from a secrets\n    vault or remote config service such as Firebase.\n 4. TLSv1.3 support. For some reason Flutter/Dio does not negotiate a connection\n    properly when only TLSv1.3 is enabled in Nginx. Investigate why this is and\n    remedy it.\n 5. Using certificates that are signed by a non-self-signed root cerificate,\n    e.g. LetsEncrypt [https://letsencrypt.org/]. With special consideration paid\n    to the validity period.\n\nBonus!\nA sample Dockerfile for Nginx to help you on your way:\n\nFROM nginx:1.19\n\nCOPY nginx.conf /etc/nginx/nginx.conf\n\nCOPY server.crt /etc/nginx/certs/\nCOPY server.key /etc/nginx/certs/\nCOPY ca.crt /etc/nginx/certs/\nCOPY ssl_passwords.txt /var/lib/nginx/ssl_passwords.txt\n\nRUN chmod 400 /etc/nginx/certs/server.key\nRUN chmod 400 /var/lib/nginx/ssl_passwords.txt\n\nEXPOSE 443\n\n\nDockerfile for NginxWhen running your Nginx container, use the following command\nif you need to debug:\n\n[nginx-debug, '-g', 'daemon off;']\n\nNginx debug commandAnd, add this to your Nginx config file to enable debug level\nlogging:\n\nerror_log /var/log/nginx/error.log debug;\n\nNginx debug level config


![img-description](/assets/img/hello.jpg)
_Hello World_
