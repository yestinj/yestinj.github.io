---
title: My Takeaways from \"Effective Java\
date: 2022-06-25T07:46:30.000Z
categories: [Java]
tags: [programming]
---

Item 1: Consider static factory methods instead of constructors\nThe traditional way for a class to allow a client to obtain an instance is to\nprovide a public constructor. There is another technique that should be a part\nof every programmer’s toolkit. A class can provide a public static factory\nmethod, which is simply a static method that returns an instance of the class.\nHere’s a simple example:\n\npublic static Boolean valueOf(boolean b) {\n\treturn b ? Boolean.TRUE : Boolean.FALSE;\n}\n\nNote that a static factory method is not the same as the Factory Method pattern\nfrom Design Patterns [Gamma95]. The static factory method described in this item\nhas no direct equivalent in Design Patterns.\n\nA class can provide its clients with static factory methods instead of, or in\naddition to, public constructors. Providing a static factory method instead of a\npublic constructor has both advantages and disadvantages.\n\nOne advantage of static factory methods is that, unlike constructors, they have\nnames. If the parameters to a constructor do not, in and of themselves, describe\nthe object being returned, a static factory with a well-chosen name is easier to\nuse and the resulting client code easier to read. For example, the constructor\nBigInteger(int, int, Random), which returns a BigInteger that is probably prime,\nwould have been better expressed as a static factory method named\nBigInteger.probablePrime. (This method was added in Java 4.)\n\nA class can have only a single constructor with a given signature. Programmers\nhave been known to get around this restriction by providing two constructors\nwhose parameter lists differ only in the order of their parameter types. This is\na really bad idea. The user of such an API will never be able to remember which\nconstructor is which and will end up calling the wrong one by mistake. People\nreading code that uses these constructors will not know what the code does\nwithout referring to the class documentation.\n\nBecause they have names, static factory methods don’t share the restriction\ndiscussed in the previous paragraph. In cases where a class seems to require\nmultiple constructors with the same signature, replace the constructors with\nstatic factory methods and carefully chosen names to highlight their\ndifferences.\n\nA second advantage of static factory methods is that, unlike constructors, they\nare not required to create a new object each time they’re invoked. This allows\nimmutable classes (Item 17) to use preconstructed instances, or to cache\ninstances as they’re constructed, and dispense them repeatedly to avoid creating\nunnecessary duplicate objects. The Boolean.valueOf(boolean) method illustrates\nthis technique: it never creates an object. This technique is similar to the\nFlyweight pattern [Gamma95]. It can greatly improve performance if equivalent\nobjects are requested often, especially if they are expensive to create.\n\nThe ability of static factory methods to return the same object from repeated\ninvocations allows classes to maintain strict control over what instances exist\nat any time. Classes that do this are said to be instance-controlled. There are\nseveral reasons to write instance-controlled classes. Instance control allows a\nclass to guarantee that it is a singleton (Item 3) or noninstantiable (Item 4).\nAlso, it allows an immutable value class (Item 17) to make the guarantee that no\ntwo equal instances exist: a.equals(b) if and only if a == b. This is the basis\nof the Flyweight pattern [Gamma95]. Enum types (Item 34) provide this guarantee.\n\nA third advantage of static factory methods is that, unlike constructors, they\ncan return an object of any subtype of their return type. This gives you great\nflexibility in choosing the class of the returned object.\n\nOne application of this flexibility is that an API can return objects without\nmaking their classes public. Hiding implementation classes in this fashion leads\nto a very compact API. This technique lends itself to interface-based frameworks\n(Item 20), where interfaces provide natural return types for static factory\nmethods.\n\nPrior to Java 8, interfaces couldn’t have static methods. By convention, static\nfactory methods for an interface named Type were put in a noninstantiable\ncompanion class (Item 4) named Types. For example, the Java Collections\nFramework has forty-five utility implementations of its interfaces, providing\nunmodifiable collections, synchronized collections, and the like. Nearly all of\nthese implementations are exported via static factory methods in one\nnoninstantiable class (java.util.Collections). The classes of the returned\nobjects are all nonpublic.\n\nThe Collections Framework API is much smaller than it would have been had it\nexported forty-five separate public classes, one for each convenience\nimplementation. It is not just the bulk of the API that is reduced but the\nconceptual weight: the number and difficulty of the concepts that programmers\nmust master in order to use the API. The programmer knows that the returned\nobject has precisely the API specified by its interface, so there is no need to\nread additional class documentation for the implementation class. Furthermore,\nusing such a static factory method requires the client to refer to the returned\nobject by interface rather than implementation class, which is generally good\npractice (Item 64).\n\nAs of Java 8, the restriction that interfaces cannot contain static methods was\neliminated, so there is typically little reason to provide a noninstantiable\ncompanion class for an interface. Many public static members that would have\nbeen at home in such a class should instead be put in the interface itself.\nNote, however, that it may still be necessary to put the bulk of the\nimplementation code behind these static methods in a separate package-private\nclass. This is because Java 8 requires all static members of an interface to be\npublic. Java 9 allows private static methods, but static fields and static\nmember classes are still required to be public.\n\nA fourth advantage of static factories is that the class of the returned object\ncan vary from call to call as a function of the input parameters. Any subtype of\nthe declared return type is permissible. The class of the returned object can\nalso vary from release to release.\n\nThe EnumSet class (Item 36) has no public constructors, only static factories.\nIn the OpenJDK implementation, they return an instance of one of two subclasses,\ndepending on the size of the underlying enum type: if it has sixty-four or fewer\nelements, as most enum types do, the static factories return a RegularEnumSet\ninstance, which is backed by a single long; if the enum type has sixty-five or\nmore elements, the factories return a JumboEnumSet instance, backed by a long\narray.\n\nThe existence of these two implementation classes is invisible to clients. If\nRegularEnumSet ceased to offer performance advantages for small enum types, it\ncould be eliminated from a future release with no ill effects. Similarly, a\nfuture release could add a third or fourth implementation of EnumSet if it\nproved beneficial for performance. Clients neither know nor care about the class\nof the object they get back from the factory; they care only that it is some\nsubclass of EnumSet.\n\nA fifth advantage of static factories is that the class of the returned object\nneed not exist when the class containing the method is written. Such flexible\nstatic factory methods form the basis of service provider frameworks, like the\nJava Database Connectivity API (JDBC). A service provider framework is a system\nin which providers implement a service, and the system makes the implementations\navailable to clients, decoupling the clients from the implementations.\n\nThere are three essential components in a service provider framework: a service\ninterface, which represents an implementation; a provider registration API,\nwhich providers use to register implementations; and a service access API, which\nclients use to obtain instances of the service. The service access API may allow\nclients to specify criteria for choosing an implementation. In the absence of\nsuch criteria, the API returns an instance of a default implementation, or\nallows the client to cycle through all available implementations. The service\naccess API is the flexible static factory that forms the basis of the service\nprovider framework.\n\nAn optional fourth component of a service provider framework is a service\nprovider interface, which describes a factory object that produces instances of\nthe service interface. In the absence of a service provider interface,\nimplementations must be instantiated reflectively (Item 65). In the case of\nJDBC, Connection plays the part of the service interface,\nDriverManager.registerDriver is the provider registration API,\nDriverManager.getConnection is the service access API, and Driver is the service\nprovider interface.\n\nThere are many variants of the service provider framework pattern. For example,\nthe service access API can return a richer service interface to clients than the\none furnished by providers. This is the Bridge pattern [Gamma95]. Dependency\ninjection frameworks (Item 5) can be viewed as powerful service providers. Since\nJava 6, the platform includes a general-purpose service provider framework,\njava.util.ServiceLoader, so you needn’t, and generally shouldn’t, write your own\n(Item 59). JDBC doesn’t use ServiceLoader, as the former predates the latter.\n\nThe main limitation of providing only static factory methods is that classes\nwithout public or protected constructors cannot be subclassed. For example, it\nis impossible to subclass any of the convenience implementation classes in the\nCollections Framework. Arguably this can be a blessing in disguise because it\nencourages programmers to use composition instead of inheritance (Item 18), and\nis required for immutable types (Item 17).\n\nA second shortcoming of static factory methods is that they are hard for\nprogrammers to find. They do not stand out in API documentation in the way that\nconstructors do, so it can be difficult to figure out how to instantiate a class\nthat provides static factory methods instead of constructors. The Javadoc tool\nmay someday draw attention to static factory methods. In the meantime, you can\nreduce this problem by drawing attention to static factories in class or\ninterface documentation and by adhering to common naming conventions. Here are\nsome common names for static factory methods. This list is far from exhaustive:\n\n• from—A type-conversion method that takes a single parameter and returns a\ncorresponding instance of this type, for example:\n\nDate d = Date.from(instant);\n\n• of—An aggregation method that takes multiple parameters and returns an\ninstance of this type that incorporates them, for example:\n\nSet faceCards = EnumSet.of(JACK, QUEEN, KING);\n\n• valueOf—A more verbose alternative to from and of, for example:\n\nBigInteger prime = BigInteger.valueOf(Integer.MAX_VALUE);\n\n• instance or getInstance—Returns an instance that is described by its\nparameters (if any) but cannot be said to have the same value, for example:\n\nStackWalker luke = StackWalker.getInstance(options);\n\n• create or newInstance—Like instance or getInstance, except that the method\nguarantees that each call returns a new instance, for example:\n\nObject newArray = Array.newInstance(classObject, arrayLen);\n\n• getType—Like getInstance, but used if the factory method is in a different\nclass. Type is the type of object returned by the factory method, for example:\n\nFileStore fs = Files.getFileStore(path);\n\n• newType—Like newInstance, but used if the factory method is in a different\nclass. Type is the type of object returned by the factory method, for example:\n\nBufferedReader br = Files.newBufferedReader(path);\n\n• type—A concise alternative to getType and newType, for example:\n\nList litany = Collections.list(legacyLitany);\n\nIn summary, static factory methods and public constructors both have their uses,\nand it pays to understand their relative merits. Often static factories are\npreferable, so avoid the reflex to provide public constructors without first\nconsidering static factories.\n\nItem 2: Consider a builder when faced with many constructor parameters\nStatic factories and constructors share a limitation: they do not scale well to\nlarge numbers of optional parameters. Consider the case of a class representing\nthe Nutrition Facts label that appears on packaged foods. These labels have a\nfew required fields—serving size, servings per container, and calories per\nserving—and more than twenty optional fields—total fat, saturated fat, trans\nfat, cholesterol, sodium, and so on. Most products have nonzero values for only\na few of these optional fields.\n\nWhat sort of constructors or static factories should you write for such a class?\nTraditionally, programmers have used the telescoping constructor pattern, in\nwhich you provide a constructor with only the required parameters, another with\na single optional parameter, a third with two optional parameters, and so on,\nculminating in a constructor with all the optional parameters. Here’s how it\nlooks in practice. For brevity’s sake, only four optional fields are shown:\n\n// Telescoping constructor pattern - does not scale well!\npublic class NutritionFacts {\nprivate final int servingSize;  // (mL)            required\nprivate final int servings;     // (per container) required\nprivate final int calories;     // (per serving)   optional\nprivate final int fat;          // (g/serving)     optional\nprivate final int sodium;       // (mg/serving)    optional\nprivate final int carbohydrate; // (g/serving)     optional\n\npublic NutritionFacts(int servingSize, int servings) {\n    this(servingSize, servings, 0);\n}\n\npublic NutritionFacts(int servingSize, int servings,\n        int calories) {\n    this(servingSize, servings, calories, 0);\n}\n\npublic NutritionFacts(int servingSize, int servings,\n        int calories, int fat) {\n    this(servingSize, servings, calories, fat, 0);\n}\n\npublic NutritionFacts(int servingSize, int servings,\n        int calories, int fat, int sodium) {\n    this(servingSize, servings, calories, fat, sodium, 0);\n}\n\npublic NutritionFacts(int servingSize, int servings,\n       int calories, int fat, int sodium, int carbohydrate) {\n    this.servingSize  = servingSize;\n    this.servings     = servings;\n    this.calories     = calories;\n    this.fat          = fat;\n    this.sodium       = sodium;\n    this.carbohydrate = carbohydrate;\n}\n\n\n}\n\nWhen you want to create an instance, you use the constructor with the shortest\nparameter list containing all the parameters you want to set:\n\nNutritionFacts cocaCola =\nnew NutritionFacts(240, 8, 100, 0, 35, 27);\n\nTypically this constructor invocation will require many parameters that you\ndon’t want to set, but you’re forced to pass a value for them anyway. In this\ncase, we passed a value of 0 for fat. With “only” six parameters this may not\nseem so bad, but it quickly gets out of hand as the number of parameters\nincreases.\n\nIn short, the telescoping constructor pattern works, but it is hard to write\nclient code when there are many parameters, and harder still to read it. The\nreader is left wondering what all those values mean and must carefully count\nparameters to find out. Long sequences of identically typed parameters can cause\nsubtle bugs. If the client accidentally reverses two such parameters, the\ncompiler won’t complain, but the program will misbehave at runtime (Item 51).\n\nA second alternative when you’re faced with many optional parameters in a\nconstructor is the JavaBeans pattern, in which you call a parameterless\nconstructor to create the object and then call setter methods to set each\nrequired parameter and each optional parameter of interest:\n\n// JavaBeans Pattern - allows inconsistency, mandates mutability\npublic class NutritionFacts {\n// Parameters initialized to default values (if any)\nprivate int servingSize  = -1; // Required; no default value\nprivate int servings     = -1; // Required; no default value\nprivate int calories     = 0;\nprivate int fat          = 0;\nprivate int sodium       = 0;\nprivate int carbohydrate = 0;\n\npublic NutritionFacts() { }\n// Setters\npublic void setServingSize(int val)  { servingSize = val; }\npublic void setServings(int val)    { servings = val; }\npublic void setCalories(int val)    { calories = val; }\npublic void setFat(int val)         { fat = val; }\npublic void setSodium(int val)      { sodium = val; }\npublic void setCarbohydrate(int val) { carbohydrate = val; }\n\n\n}. \n\nNutritionFacts cocaCola = new NutritionFacts();\ncocaCola.setServingSize(240);\ncocaCola.setServings(8);\ncocaCola.setCalories(100);\ncocaCola.setSodium(35);\ncocaCola.setCarbohydrate(27);\n\nUnfortunately, the JavaBeans pattern has serious disadvantages of its own.\nBecause construction is split across multiple calls, a JavaBean may be in an\ninconsistent state partway through its construction. The class does not have the\noption of enforcing consistency merely by checking the validity of the\nconstructor parameters. Attempting to use an object when it’s in an inconsistent\nstate may cause failures that are far removed from the code containing the bug\nand hence difficult to debug. A related disadvantage is that the JavaBeans\npattern precludes the possibility of making a class immutable (Item 17) and\nrequires added effort on the part of the programmer to ensure thread safety.\n\nIt is possible to reduce these disadvantages by manually “freezing” the object\nwhen its construction is complete and not allowing it to be used until frozen,\nbut this variant is unwieldy and rarely used in practice. Moreover, it can cause\nerrors at runtime because the compiler cannot ensure that the programmer calls\nthe freeze method on an object before using it.\n\nLuckily, there is a third alternative that combines the safety of the\ntelescoping constructor pattern with the readability of the JavaBeans pattern.\nIt is a form of the Builder pattern [Gamma95]. Instead of making the desired\nobject directly, the client calls a constructor (or static factory) with all of\nthe required parameters and gets a builder object. Then the client calls\nsetter-like methods on the builder object to set each optional parameter of\ninterest. Finally, the client calls a parameterless build method to generate the\nobject, which is typically immutable. The builder is typically a static member\nclass (Item 24) of the class it builds. Here’s how it looks in practice:\n\n// Builder Pattern\npublic class NutritionFacts {\nprivate final int servingSize;\nprivate final int servings;\nprivate final int calories;\nprivate final int fat;\nprivate final int sodium;\nprivate final int carbohydrate;\n\npublic static class Builder {\n    // Required parameters\n    private final int servingSize;\n    private final int servings;\n\n    // Optional parameters - initialized to default values\n    private int calories      = 0;\n    private int fat           = 0;\n    private int sodium        = 0;\n    private int carbohydrate  = 0;\n\n    public Builder(int servingSize, int servings) {\n        this.servingSize = servingSize;\n        this.servings    = servings;\n    }\n\n    public Builder calories(int val)\n        { calories = val;      return this; }\n    public Builder fat(int val)\n        { fat = val;           return this; }\n    public Builder sodium(int val)\n        { sodium = val;        return this; }\n    public Builder carbohydrate(int val)\n        { carbohydrate = val;  return this; }\n\n    public NutritionFacts build() {\n        return new NutritionFacts(this);\n    }\n}\n\nprivate NutritionFacts(Builder builder) {\n    servingSize  = builder.servingSize;\n    servings     = builder.servings;\n    calories     = builder.calories;\n    fat          = builder.fat;\n    sodium       = builder.sodium;\n    carbohydrate = builder.carbohydrate;\n}\n\n\n}\n\nThe NutritionFacts class is immutable, and all parameter default values are in\none place. The builder’s setter methods return the builder itself so that\ninvocations can be chained, resulting in a fluent API. Here’s how the client\ncode looks:\n\nNutritionFacts cocaCola = new NutritionFacts.Builder(240, 8)\n.calories(100).sodium(35).carbohydrate(27).build();\n\nThis client code is easy to write and, more importantly, easy to read. The\nBuilder pattern simulates named optional parameters as found in Python and\nScala.\n\nValidity checks were omitted for brevity. To detect invalid parameters as soon\nas possible, check parameter validity in the builder’s constructor and methods.\nCheck invariants involving multiple parameters in the constructor invoked by the\nbuild method. To ensure these invariants against attack, do the checks on object\nfields after copying parameters from the builder (Item 50). If a check fails,\nthrow an IllegalArgumentException (Item 72) whose detail message indicates which\nparameters are invalid (Item 75).\n\nThe Builder pattern is well suited to class hierarchies. Use a parallel\nhierarchy of builders, each nested in the corresponding class. Abstract classes\nhave abstract builders; concrete classes have concrete builders. For example,\nconsider an abstract class at the root of a hierarchy representing various kinds\nof pizza:\n\n// Builder pattern for class hierarchies\npublic abstract class Pizza {\npublic enum Topping { HAM, MUSHROOM, ONION, PEPPER, SAUSAGE }\nfinal Set toppings;\n\nabstract static class Builder<T extends Builder> {\nEnumSet toppings = EnumSet.noneOf(Topping.class);\npublic T addTopping(Topping topping) {\ntoppings.add(Objects.requireNonNull(topping));\nreturn self();\n}\n\n  abstract Pizza build();\n\n  // Subclasses must override this method to return \"this\"\n  protected abstract T self();\n\n\n}\nPizza(Builder<?> builder) {\ntoppings = builder.toppings.clone(); // See Item  50\n}\n}\n\nNote that Pizza.Builder is a generic type with a recursive type parameter (Item\n30). This, along with the abstract self method, allows method chaining to work\nproperly in subclasses, without the need for casts. This workaround for the fact\nthat Java lacks a self type is known as the simulated self-type idiom.\n\nHere are two concrete subclasses of Pizza, one of which represents a standard\nNew-York-style pizza, the other a calzone. The former has a required size\nparameter, while the latter lets you specify whether sauce should be inside or\nout:\n\npublic class NyPizza extends Pizza {\npublic enum Size { SMALL, MEDIUM, LARGE }\nprivate final Size size;\n\npublic static class Builder extends Pizza.Builder<Builder> {\n    private final Size size;\n\n    public Builder(Size size) {\n        this.size = Objects.requireNonNull(size);\n    }\n\n    @Override public NyPizza build() {\n        return new NyPizza(this);\n    }\n\n    @Override protected Builder self() { return this; }\n}\n\nprivate NyPizza(Builder builder) {\n    super(builder);\n    size = builder.size;\n}\n\n\n}\n\npublic class Calzone extends Pizza {\nprivate final boolean sauceInside;\n\npublic static class Builder extends Pizza.Builder<Builder> {\n    private boolean sauceInside = false; // Default\n\n    public Builder sauceInside() {\n        sauceInside = true;\n        return this;\n    }\n\n    @Override public Calzone build() {\n        return new Calzone(this);\n    }\n\n    @Override protected Builder self() { return this; }\n}\n\nprivate Calzone(Builder builder) {\n    super(builder);\n    sauceInside = builder.sauceInside;\n}\n\n\n}\n\nNote that the build method in each subclass’s builder is declared to return the\ncorrect subclass: the build method of NyPizza.Builder returns NyPizza, while the\none in Calzone.Builder returns Calzone. This technique, wherein a subclass\nmethod is declared to return a subtype of the return type declared in the\nsuper-class, is known as covariant return typing. It allows clients to use these\nbuilders without the need for casting.\n\nThe client code for these “hierarchical builders” is essentially identical to\nthe code for the simple NutritionFacts builder. The example client code shown\nnext assumes static imports on enum constants for brevity:\n\nNyPizza pizza = new NyPizza.Builder(SMALL)\n.addTopping(SAUSAGE).addTopping(ONION).build();\nCalzone calzone = new Calzone.Builder()\n.addTopping(HAM).sauceInside().build();\n\nA minor advantage of builders over constructors is that builders can have\nmultiple varargs parameters because each parameter is specified in its own\nmethod. Alternatively, builders can aggregate the parameters passed into\nmultiple calls to a method into a single field, as demonstrated in the\naddTopping method earlier.\n\nThe Builder pattern is quite flexible. A single builder can be used repeatedly\nto build multiple objects. The parameters of the builder can be tweaked between\ninvocations of the build method to vary the objects that are created. A builder\ncan fill in some fields automatically upon object creation, such as a serial\nnumber that increases each time an object is created.\n\nThe Builder pattern has disadvantages as well. In order to create an object, you\nmust first create its builder. While the cost of creating this builder is\nunlikely to be noticeable in practice, it could be a problem in\nperformance-critical situations. Also, the Builder pattern is more verbose than\nthe telescoping constructor pattern, so it should be used only if there are\nenough parameters to make it worthwhile, say four or more. But keep in mind that\nyou may want to add more parameters in the future. But if you start out with\nconstructors or static factories and switch to a builder when the class evolves\nto the point where the number of parameters gets out of hand, the obsolete\nconstructors or static factories will stick out like a sore thumb. Therefore,\nit’s often better to start with a builder in the first place.\n\nIn summary, the Builder pattern is a good choice when designing classes whose\nconstructors or static factories would have more than a handful of parameters,\nespecially if many of the parameters are optional or of identical type. Client\ncode is much easier to read and write with builders than with telescoping\nconstructors, and builders are much safer than JavaBeans.\n\nItem 3: Enforce the singleton property with a private constructor or an enum\ntype\nA singleton is simply a class that is instantiated exactly once [Gamma95].\nSingletons typically represent either a stateless object such as a function\n(Item 24) or a system component that is intrinsically unique. Making a class a\nsingleton can make it difficult to test its clients because it’s impossible to\nsubstitute a mock implementation for a singleton unless it implements an\ninterface that serves as its type.\n\nThere are two common ways to implement singletons. Both are based on keeping the\nconstructor private and exporting a public static member to provide access to\nthe sole instance. In one approach, the member is a final field:\n\n// Singleton with public final field\npublic class Elvis {\npublic static final Elvis INSTANCE = new Elvis();\nprivate Elvis() { ... }\n\npublic void leaveTheBuilding() { ... }\n\n\n}\n\nThe private constructor is called only once, to initialize the public static\nfinal field Elvis.INSTANCE. The lack of a public or protected constructor\nguarantees a “monoelvistic” universe: exactly one Elvis instance will exist once\nthe Elvis class is initialized—no more, no less. Nothing that a client does can\nchange this, with one caveat: a privileged client can invoke the private\nconstructor reflectively (Item 65) with the aid of the\nAccessibleObject.setAccessible method. If you need to defend against this\nattack, modify the constructor to make it throw an exception if it’s asked to\ncreate a second instance.\n\nIn the second approach to implementing singletons, the public member is a static\nfactory method:\n\n// Singleton with static factory\npublic class Elvis {\nprivate static final Elvis INSTANCE = new Elvis();\nprivate Elvis() { ... }\npublic static Elvis getInstance() { return INSTANCE; }\n\npublic void leaveTheBuilding() { ... }\n\n\n}\n\nAll calls to Elvis.getInstance return the same object reference, and no other\nElvis instance will ever be created (with the same caveat mentioned earlier).\n\nThe main advantage of the public field approach is that the API makes it clear\nthat the class is a singleton: the public static field is final, so it will\nalways contain the same object reference. The second advantage is that it’s\nsimpler.\n\nOne advantage of the static factory approach is that it gives you the\nflexibility to change your mind about whether the class is a singleton without\nchanging its API. The factory method returns the sole instance, but it could be\nmodified to return, say, a separate instance for each thread that invokes it. A\nsecond advantage is that you can write a generic singleton factory if your\napplication requires it (Item 30). A final advantage of using a static factory\nis that a method reference can be used as a supplier, for example\nElvis::instance is a Supplier. Unless one of these advantages is relevant, the\npublic field approach is preferable.\n\nTo make a singleton class that uses either of these approaches serializable\n(Chapter 12), it is not sufficient merely to add implements Serializable to its\ndeclaration. To maintain the singleton guarantee, declare all instance fields\ntransient and provide a readResolve method (Item 89). Otherwise, each time a\nserialized instance is deserialized, a new instance will be created, leading, in\nthe case of our example, to spurious Elvis sightings. To prevent this from\nhappening, add this readResolve method to the Elvis class:\n\n// readResolve method to preserve singleton property\nprivate Object readResolve() {\n// Return the one true Elvis and let the garbage collector\n// take care of the Elvis impersonator.\nreturn INSTANCE;\n}\n\nA third way to implement a singleton is to declare a single-element enum:\n\n// Enum singleton - the preferred approach\npublic enum Elvis {\nINSTANCE;\n\npublic void leaveTheBuilding() { ... }\n\n\n}\n\nThis approach is similar to the public field approach, but it is more concise,\nprovides the serialization machinery for free, and provides an ironclad\nguarantee against multiple instantiation, even in the face of sophisticated\nserialization or reflection attacks. This approach may feel a bit unnatural, but\na single-element enum type is often the best way to implement a singleton. Note\nthat you can’t use this approach if your singleton must extend a superclass\nother than Enum (though you can declare an enum to implement interfaces).

![img-description](/assets/img/hello.jpg)
_Hello World_
